// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: waf_format.proto

#ifndef PROTOBUF_waf_5fformat_2eproto__INCLUDED
#define PROTOBUF_waf_5fformat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_waf_5fformat_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDetailsImpl();
void InitDefaultsDetails();
void InitDefaultsWaf_FormatImpl();
void InitDefaultsWaf_Format();
inline void InitDefaults() {
  InitDefaultsDetails();
  InitDefaultsWaf_Format();
}
}  // namespace protobuf_waf_5fformat_2eproto
namespace waf_format {
class Details;
class DetailsDefaultTypeInternal;
extern DetailsDefaultTypeInternal _Details_default_instance_;
class Waf_Format;
class Waf_FormatDefaultTypeInternal;
extern Waf_FormatDefaultTypeInternal _Waf_Format_default_instance_;
}  // namespace waf_format
namespace waf_format {

enum Waf_Format_ActionType {
  Waf_Format_ActionType_Detected = 0,
  Waf_Format_ActionType_Blocked = 1
};
bool Waf_Format_ActionType_IsValid(int value);
const Waf_Format_ActionType Waf_Format_ActionType_ActionType_MIN = Waf_Format_ActionType_Detected;
const Waf_Format_ActionType Waf_Format_ActionType_ActionType_MAX = Waf_Format_ActionType_Blocked;
const int Waf_Format_ActionType_ActionType_ARRAYSIZE = Waf_Format_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Waf_Format_ActionType_descriptor();
inline const ::std::string& Waf_Format_ActionType_Name(Waf_Format_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Waf_Format_ActionType_descriptor(), value);
}
inline bool Waf_Format_ActionType_Parse(
    const ::std::string& name, Waf_Format_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Waf_Format_ActionType>(
    Waf_Format_ActionType_descriptor(), name, value);
}
enum Waf_Format_SiteType {
  Waf_Format_SiteType_Global = 0
};
bool Waf_Format_SiteType_IsValid(int value);
const Waf_Format_SiteType Waf_Format_SiteType_SiteType_MIN = Waf_Format_SiteType_Global;
const Waf_Format_SiteType Waf_Format_SiteType_SiteType_MAX = Waf_Format_SiteType_Global;
const int Waf_Format_SiteType_SiteType_ARRAYSIZE = Waf_Format_SiteType_SiteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Waf_Format_SiteType_descriptor();
inline const ::std::string& Waf_Format_SiteType_Name(Waf_Format_SiteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Waf_Format_SiteType_descriptor(), value);
}
inline bool Waf_Format_SiteType_Parse(
    const ::std::string& name, Waf_Format_SiteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Waf_Format_SiteType>(
    Waf_Format_SiteType_descriptor(), name, value);
}
// ===================================================================

class Details : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:waf_format.Details) */ {
 public:
  Details();
  virtual ~Details();

  Details(const Details& from);

  inline Details& operator=(const Details& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Details(Details&& from) noexcept
    : Details() {
    *this = ::std::move(from);
  }

  inline Details& operator=(Details&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Details& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Details* internal_default_instance() {
    return reinterpret_cast<const Details*>(
               &_Details_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Details* other);
  friend void swap(Details& a, Details& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Details* New() const PROTOBUF_FINAL { return New(NULL); }

  Details* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Details& from);
  void MergeFrom(const Details& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Details* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string messages = 1;
  bool has_messages() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  const ::std::string& messages() const;
  void set_messages(const ::std::string& value);
  #if LANG_CXX11
  void set_messages(::std::string&& value);
  #endif
  void set_messages(const char* value);
  void set_messages(const char* value, size_t size);
  ::std::string* mutable_messages();
  ::std::string* release_messages();
  void set_allocated_messages(::std::string* messages);

  // optional string data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional string file = 3;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // optional string line = 4;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 4;
  const ::std::string& line() const;
  void set_line(const ::std::string& value);
  #if LANG_CXX11
  void set_line(::std::string&& value);
  #endif
  void set_line(const char* value);
  void set_line(const char* value, size_t size);
  ::std::string* mutable_line();
  ::std::string* release_line();
  void set_allocated_line(::std::string* line);

  // @@protoc_insertion_point(class_scope:waf_format.Details)
 private:
  void set_has_messages();
  void clear_has_messages();
  void set_has_data();
  void clear_has_data();
  void set_has_file();
  void clear_has_file();
  void set_has_line();
  void clear_has_line();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messages_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::internal::ArenaStringPtr line_;
  friend struct ::protobuf_waf_5fformat_2eproto::TableStruct;
  friend void ::protobuf_waf_5fformat_2eproto::InitDefaultsDetailsImpl();
};
// -------------------------------------------------------------------

class Waf_Format : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:waf_format.Waf_Format) */ {
 public:
  Waf_Format();
  virtual ~Waf_Format();

  Waf_Format(const Waf_Format& from);

  inline Waf_Format& operator=(const Waf_Format& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Waf_Format(Waf_Format&& from) noexcept
    : Waf_Format() {
    *this = ::std::move(from);
  }

  inline Waf_Format& operator=(Waf_Format&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Waf_Format& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waf_Format* internal_default_instance() {
    return reinterpret_cast<const Waf_Format*>(
               &_Waf_Format_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Waf_Format* other);
  friend void swap(Waf_Format& a, Waf_Format& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Waf_Format* New() const PROTOBUF_FINAL { return New(NULL); }

  Waf_Format* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Waf_Format& from);
  void MergeFrom(const Waf_Format& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Waf_Format* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Waf_Format_ActionType ActionType;
  static const ActionType Detected =
    Waf_Format_ActionType_Detected;
  static const ActionType Blocked =
    Waf_Format_ActionType_Blocked;
  static inline bool ActionType_IsValid(int value) {
    return Waf_Format_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Waf_Format_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Waf_Format_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Waf_Format_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Waf_Format_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Waf_Format_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Waf_Format_ActionType_Parse(name, value);
  }

  typedef Waf_Format_SiteType SiteType;
  static const SiteType Global =
    Waf_Format_SiteType_Global;
  static inline bool SiteType_IsValid(int value) {
    return Waf_Format_SiteType_IsValid(value);
  }
  static const SiteType SiteType_MIN =
    Waf_Format_SiteType_SiteType_MIN;
  static const SiteType SiteType_MAX =
    Waf_Format_SiteType_SiteType_MAX;
  static const int SiteType_ARRAYSIZE =
    Waf_Format_SiteType_SiteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SiteType_descriptor() {
    return Waf_Format_SiteType_descriptor();
  }
  static inline const ::std::string& SiteType_Name(SiteType value) {
    return Waf_Format_SiteType_Name(value);
  }
  static inline bool SiteType_Parse(const ::std::string& name,
      SiteType* value) {
    return Waf_Format_SiteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string clientIP = 1;
  bool has_clientip() const;
  void clear_clientip();
  static const int kClientIPFieldNumber = 1;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // optional string clientPort = 2;
  bool has_clientport() const;
  void clear_clientport();
  static const int kClientPortFieldNumber = 2;
  const ::std::string& clientport() const;
  void set_clientport(const ::std::string& value);
  #if LANG_CXX11
  void set_clientport(::std::string&& value);
  #endif
  void set_clientport(const char* value);
  void set_clientport(const char* value, size_t size);
  ::std::string* mutable_clientport();
  ::std::string* release_clientport();
  void set_allocated_clientport(::std::string* clientport);

  // optional string requestUri = 3;
  bool has_requesturi() const;
  void clear_requesturi();
  static const int kRequestUriFieldNumber = 3;
  const ::std::string& requesturi() const;
  void set_requesturi(const ::std::string& value);
  #if LANG_CXX11
  void set_requesturi(::std::string&& value);
  #endif
  void set_requesturi(const char* value);
  void set_requesturi(const char* value, size_t size);
  ::std::string* mutable_requesturi();
  ::std::string* release_requesturi();
  void set_allocated_requesturi(::std::string* requesturi);

  // optional string ruleSetType = 4;
  bool has_rulesettype() const;
  void clear_rulesettype();
  static const int kRuleSetTypeFieldNumber = 4;
  const ::std::string& rulesettype() const;
  void set_rulesettype(const ::std::string& value);
  #if LANG_CXX11
  void set_rulesettype(::std::string&& value);
  #endif
  void set_rulesettype(const char* value);
  void set_rulesettype(const char* value, size_t size);
  ::std::string* mutable_rulesettype();
  ::std::string* release_rulesettype();
  void set_allocated_rulesettype(::std::string* rulesettype);

  // optional string ruleSetVersion = 5;
  bool has_rulesetversion() const;
  void clear_rulesetversion();
  static const int kRuleSetVersionFieldNumber = 5;
  const ::std::string& rulesetversion() const;
  void set_rulesetversion(const ::std::string& value);
  #if LANG_CXX11
  void set_rulesetversion(::std::string&& value);
  #endif
  void set_rulesetversion(const char* value);
  void set_rulesetversion(const char* value, size_t size);
  ::std::string* mutable_rulesetversion();
  ::std::string* release_rulesetversion();
  void set_allocated_rulesetversion(::std::string* rulesetversion);

  // optional string ruleId = 6;
  bool has_ruleid() const;
  void clear_ruleid();
  static const int kRuleIdFieldNumber = 6;
  const ::std::string& ruleid() const;
  void set_ruleid(const ::std::string& value);
  #if LANG_CXX11
  void set_ruleid(::std::string&& value);
  #endif
  void set_ruleid(const char* value);
  void set_ruleid(const char* value, size_t size);
  ::std::string* mutable_ruleid();
  ::std::string* release_ruleid();
  void set_allocated_ruleid(::std::string* ruleid);

  // optional string messages = 7;
  bool has_messages() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 7;
  const ::std::string& messages() const;
  void set_messages(const ::std::string& value);
  #if LANG_CXX11
  void set_messages(::std::string&& value);
  #endif
  void set_messages(const char* value);
  void set_messages(const char* value, size_t size);
  ::std::string* mutable_messages();
  ::std::string* release_messages();
  void set_allocated_messages(::std::string* messages);

  // optional string hostname = 11;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 11;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional .waf_format.Details details = 10;
  bool has_details() const;
  void clear_details();
  static const int kDetailsFieldNumber = 10;
  const ::waf_format::Details& details() const;
  ::waf_format::Details* release_details();
  ::waf_format::Details* mutable_details();
  void set_allocated_details(::waf_format::Details* details);

  // optional .waf_format.Waf_Format.ActionType action = 8;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 8;
  ::waf_format::Waf_Format_ActionType action() const;
  void set_action(::waf_format::Waf_Format_ActionType value);

  // optional .waf_format.Waf_Format.SiteType site = 9;
  bool has_site() const;
  void clear_site();
  static const int kSiteFieldNumber = 9;
  ::waf_format::Waf_Format_SiteType site() const;
  void set_site(::waf_format::Waf_Format_SiteType value);

  // @@protoc_insertion_point(class_scope:waf_format.Waf_Format)
 private:
  void set_has_clientip();
  void clear_has_clientip();
  void set_has_clientport();
  void clear_has_clientport();
  void set_has_requesturi();
  void clear_has_requesturi();
  void set_has_rulesettype();
  void clear_has_rulesettype();
  void set_has_rulesetversion();
  void clear_has_rulesetversion();
  void set_has_ruleid();
  void clear_has_ruleid();
  void set_has_messages();
  void clear_has_messages();
  void set_has_action();
  void clear_has_action();
  void set_has_site();
  void clear_has_site();
  void set_has_details();
  void clear_has_details();
  void set_has_hostname();
  void clear_has_hostname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  ::google::protobuf::internal::ArenaStringPtr clientport_;
  ::google::protobuf::internal::ArenaStringPtr requesturi_;
  ::google::protobuf::internal::ArenaStringPtr rulesettype_;
  ::google::protobuf::internal::ArenaStringPtr rulesetversion_;
  ::google::protobuf::internal::ArenaStringPtr ruleid_;
  ::google::protobuf::internal::ArenaStringPtr messages_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::waf_format::Details* details_;
  int action_;
  int site_;
  friend struct ::protobuf_waf_5fformat_2eproto::TableStruct;
  friend void ::protobuf_waf_5fformat_2eproto::InitDefaultsWaf_FormatImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Details

// optional string messages = 1;
inline bool Details::has_messages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Details::set_has_messages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Details::clear_has_messages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Details::clear_messages() {
  messages_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messages();
}
inline const ::std::string& Details::messages() const {
  // @@protoc_insertion_point(field_get:waf_format.Details.messages)
  return messages_.GetNoArena();
}
inline void Details::set_messages(const ::std::string& value) {
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Details.messages)
}
#if LANG_CXX11
inline void Details::set_messages(::std::string&& value) {
  set_has_messages();
  messages_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Details.messages)
}
#endif
inline void Details::set_messages(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Details.messages)
}
inline void Details::set_messages(const char* value, size_t size) {
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Details.messages)
}
inline ::std::string* Details::mutable_messages() {
  set_has_messages();
  // @@protoc_insertion_point(field_mutable:waf_format.Details.messages)
  return messages_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Details::release_messages() {
  // @@protoc_insertion_point(field_release:waf_format.Details.messages)
  clear_has_messages();
  return messages_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Details::set_allocated_messages(::std::string* messages) {
  if (messages != NULL) {
    set_has_messages();
  } else {
    clear_has_messages();
  }
  messages_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messages);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Details.messages)
}

// optional string data = 2;
inline bool Details::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Details::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Details::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Details::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Details::data() const {
  // @@protoc_insertion_point(field_get:waf_format.Details.data)
  return data_.GetNoArena();
}
inline void Details::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Details.data)
}
#if LANG_CXX11
inline void Details::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Details.data)
}
#endif
inline void Details::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Details.data)
}
inline void Details::set_data(const char* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Details.data)
}
inline ::std::string* Details::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:waf_format.Details.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Details::release_data() {
  // @@protoc_insertion_point(field_release:waf_format.Details.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Details::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Details.data)
}

// optional string file = 3;
inline bool Details::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Details::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Details::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Details::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file();
}
inline const ::std::string& Details::file() const {
  // @@protoc_insertion_point(field_get:waf_format.Details.file)
  return file_.GetNoArena();
}
inline void Details::set_file(const ::std::string& value) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Details.file)
}
#if LANG_CXX11
inline void Details::set_file(::std::string&& value) {
  set_has_file();
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Details.file)
}
#endif
inline void Details::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Details.file)
}
inline void Details::set_file(const char* value, size_t size) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Details.file)
}
inline ::std::string* Details::mutable_file() {
  set_has_file();
  // @@protoc_insertion_point(field_mutable:waf_format.Details.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Details::release_file() {
  // @@protoc_insertion_point(field_release:waf_format.Details.file)
  clear_has_file();
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Details::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    set_has_file();
  } else {
    clear_has_file();
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Details.file)
}

// optional string line = 4;
inline bool Details::has_line() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Details::set_has_line() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Details::clear_has_line() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Details::clear_line() {
  line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_line();
}
inline const ::std::string& Details::line() const {
  // @@protoc_insertion_point(field_get:waf_format.Details.line)
  return line_.GetNoArena();
}
inline void Details::set_line(const ::std::string& value) {
  set_has_line();
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Details.line)
}
#if LANG_CXX11
inline void Details::set_line(::std::string&& value) {
  set_has_line();
  line_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Details.line)
}
#endif
inline void Details::set_line(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_line();
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Details.line)
}
inline void Details::set_line(const char* value, size_t size) {
  set_has_line();
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Details.line)
}
inline ::std::string* Details::mutable_line() {
  set_has_line();
  // @@protoc_insertion_point(field_mutable:waf_format.Details.line)
  return line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Details::release_line() {
  // @@protoc_insertion_point(field_release:waf_format.Details.line)
  clear_has_line();
  return line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Details::set_allocated_line(::std::string* line) {
  if (line != NULL) {
    set_has_line();
  } else {
    clear_has_line();
  }
  line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), line);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Details.line)
}

// -------------------------------------------------------------------

// Waf_Format

// optional string clientIP = 1;
inline bool Waf_Format::has_clientip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Waf_Format::set_has_clientip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Waf_Format::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Waf_Format::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientip();
}
inline const ::std::string& Waf_Format::clientip() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.clientIP)
  return clientip_.GetNoArena();
}
inline void Waf_Format::set_clientip(const ::std::string& value) {
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.clientIP)
}
#if LANG_CXX11
inline void Waf_Format::set_clientip(::std::string&& value) {
  set_has_clientip();
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.clientIP)
}
#endif
inline void Waf_Format::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.clientIP)
}
inline void Waf_Format::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.clientIP)
}
inline ::std::string* Waf_Format::mutable_clientip() {
  set_has_clientip();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.clientIP)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_clientip() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.clientIP)
  clear_has_clientip();
  return clientip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    set_has_clientip();
  } else {
    clear_has_clientip();
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.clientIP)
}

// optional string clientPort = 2;
inline bool Waf_Format::has_clientport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Waf_Format::set_has_clientport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Waf_Format::clear_has_clientport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Waf_Format::clear_clientport() {
  clientport_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientport();
}
inline const ::std::string& Waf_Format::clientport() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.clientPort)
  return clientport_.GetNoArena();
}
inline void Waf_Format::set_clientport(const ::std::string& value) {
  set_has_clientport();
  clientport_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.clientPort)
}
#if LANG_CXX11
inline void Waf_Format::set_clientport(::std::string&& value) {
  set_has_clientport();
  clientport_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.clientPort)
}
#endif
inline void Waf_Format::set_clientport(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientport();
  clientport_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.clientPort)
}
inline void Waf_Format::set_clientport(const char* value, size_t size) {
  set_has_clientport();
  clientport_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.clientPort)
}
inline ::std::string* Waf_Format::mutable_clientport() {
  set_has_clientport();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.clientPort)
  return clientport_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_clientport() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.clientPort)
  clear_has_clientport();
  return clientport_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_clientport(::std::string* clientport) {
  if (clientport != NULL) {
    set_has_clientport();
  } else {
    clear_has_clientport();
  }
  clientport_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientport);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.clientPort)
}

// optional string requestUri = 3;
inline bool Waf_Format::has_requesturi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Waf_Format::set_has_requesturi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Waf_Format::clear_has_requesturi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Waf_Format::clear_requesturi() {
  requesturi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requesturi();
}
inline const ::std::string& Waf_Format::requesturi() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.requestUri)
  return requesturi_.GetNoArena();
}
inline void Waf_Format::set_requesturi(const ::std::string& value) {
  set_has_requesturi();
  requesturi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.requestUri)
}
#if LANG_CXX11
inline void Waf_Format::set_requesturi(::std::string&& value) {
  set_has_requesturi();
  requesturi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.requestUri)
}
#endif
inline void Waf_Format::set_requesturi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_requesturi();
  requesturi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.requestUri)
}
inline void Waf_Format::set_requesturi(const char* value, size_t size) {
  set_has_requesturi();
  requesturi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.requestUri)
}
inline ::std::string* Waf_Format::mutable_requesturi() {
  set_has_requesturi();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.requestUri)
  return requesturi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_requesturi() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.requestUri)
  clear_has_requesturi();
  return requesturi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_requesturi(::std::string* requesturi) {
  if (requesturi != NULL) {
    set_has_requesturi();
  } else {
    clear_has_requesturi();
  }
  requesturi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requesturi);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.requestUri)
}

// optional string ruleSetType = 4;
inline bool Waf_Format::has_rulesettype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Waf_Format::set_has_rulesettype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Waf_Format::clear_has_rulesettype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Waf_Format::clear_rulesettype() {
  rulesettype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rulesettype();
}
inline const ::std::string& Waf_Format::rulesettype() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.ruleSetType)
  return rulesettype_.GetNoArena();
}
inline void Waf_Format::set_rulesettype(const ::std::string& value) {
  set_has_rulesettype();
  rulesettype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.ruleSetType)
}
#if LANG_CXX11
inline void Waf_Format::set_rulesettype(::std::string&& value) {
  set_has_rulesettype();
  rulesettype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.ruleSetType)
}
#endif
inline void Waf_Format::set_rulesettype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rulesettype();
  rulesettype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.ruleSetType)
}
inline void Waf_Format::set_rulesettype(const char* value, size_t size) {
  set_has_rulesettype();
  rulesettype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.ruleSetType)
}
inline ::std::string* Waf_Format::mutable_rulesettype() {
  set_has_rulesettype();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.ruleSetType)
  return rulesettype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_rulesettype() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.ruleSetType)
  clear_has_rulesettype();
  return rulesettype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_rulesettype(::std::string* rulesettype) {
  if (rulesettype != NULL) {
    set_has_rulesettype();
  } else {
    clear_has_rulesettype();
  }
  rulesettype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rulesettype);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.ruleSetType)
}

// optional string ruleSetVersion = 5;
inline bool Waf_Format::has_rulesetversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Waf_Format::set_has_rulesetversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Waf_Format::clear_has_rulesetversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Waf_Format::clear_rulesetversion() {
  rulesetversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rulesetversion();
}
inline const ::std::string& Waf_Format::rulesetversion() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.ruleSetVersion)
  return rulesetversion_.GetNoArena();
}
inline void Waf_Format::set_rulesetversion(const ::std::string& value) {
  set_has_rulesetversion();
  rulesetversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.ruleSetVersion)
}
#if LANG_CXX11
inline void Waf_Format::set_rulesetversion(::std::string&& value) {
  set_has_rulesetversion();
  rulesetversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.ruleSetVersion)
}
#endif
inline void Waf_Format::set_rulesetversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rulesetversion();
  rulesetversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.ruleSetVersion)
}
inline void Waf_Format::set_rulesetversion(const char* value, size_t size) {
  set_has_rulesetversion();
  rulesetversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.ruleSetVersion)
}
inline ::std::string* Waf_Format::mutable_rulesetversion() {
  set_has_rulesetversion();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.ruleSetVersion)
  return rulesetversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_rulesetversion() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.ruleSetVersion)
  clear_has_rulesetversion();
  return rulesetversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_rulesetversion(::std::string* rulesetversion) {
  if (rulesetversion != NULL) {
    set_has_rulesetversion();
  } else {
    clear_has_rulesetversion();
  }
  rulesetversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rulesetversion);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.ruleSetVersion)
}

// optional string ruleId = 6;
inline bool Waf_Format::has_ruleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Waf_Format::set_has_ruleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Waf_Format::clear_has_ruleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Waf_Format::clear_ruleid() {
  ruleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ruleid();
}
inline const ::std::string& Waf_Format::ruleid() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.ruleId)
  return ruleid_.GetNoArena();
}
inline void Waf_Format::set_ruleid(const ::std::string& value) {
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.ruleId)
}
#if LANG_CXX11
inline void Waf_Format::set_ruleid(::std::string&& value) {
  set_has_ruleid();
  ruleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.ruleId)
}
#endif
inline void Waf_Format::set_ruleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.ruleId)
}
inline void Waf_Format::set_ruleid(const char* value, size_t size) {
  set_has_ruleid();
  ruleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.ruleId)
}
inline ::std::string* Waf_Format::mutable_ruleid() {
  set_has_ruleid();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.ruleId)
  return ruleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_ruleid() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.ruleId)
  clear_has_ruleid();
  return ruleid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_ruleid(::std::string* ruleid) {
  if (ruleid != NULL) {
    set_has_ruleid();
  } else {
    clear_has_ruleid();
  }
  ruleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ruleid);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.ruleId)
}

// optional string messages = 7;
inline bool Waf_Format::has_messages() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Waf_Format::set_has_messages() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Waf_Format::clear_has_messages() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Waf_Format::clear_messages() {
  messages_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messages();
}
inline const ::std::string& Waf_Format::messages() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.messages)
  return messages_.GetNoArena();
}
inline void Waf_Format::set_messages(const ::std::string& value) {
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.messages)
}
#if LANG_CXX11
inline void Waf_Format::set_messages(::std::string&& value) {
  set_has_messages();
  messages_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.messages)
}
#endif
inline void Waf_Format::set_messages(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.messages)
}
inline void Waf_Format::set_messages(const char* value, size_t size) {
  set_has_messages();
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.messages)
}
inline ::std::string* Waf_Format::mutable_messages() {
  set_has_messages();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.messages)
  return messages_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_messages() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.messages)
  clear_has_messages();
  return messages_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_messages(::std::string* messages) {
  if (messages != NULL) {
    set_has_messages();
  } else {
    clear_has_messages();
  }
  messages_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messages);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.messages)
}

// optional .waf_format.Waf_Format.ActionType action = 8;
inline bool Waf_Format::has_action() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Waf_Format::set_has_action() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Waf_Format::clear_has_action() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Waf_Format::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::waf_format::Waf_Format_ActionType Waf_Format::action() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.action)
  return static_cast< ::waf_format::Waf_Format_ActionType >(action_);
}
inline void Waf_Format::set_action(::waf_format::Waf_Format_ActionType value) {
  assert(::waf_format::Waf_Format_ActionType_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.action)
}

// optional .waf_format.Waf_Format.SiteType site = 9;
inline bool Waf_Format::has_site() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Waf_Format::set_has_site() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Waf_Format::clear_has_site() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Waf_Format::clear_site() {
  site_ = 0;
  clear_has_site();
}
inline ::waf_format::Waf_Format_SiteType Waf_Format::site() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.site)
  return static_cast< ::waf_format::Waf_Format_SiteType >(site_);
}
inline void Waf_Format::set_site(::waf_format::Waf_Format_SiteType value) {
  assert(::waf_format::Waf_Format_SiteType_IsValid(value));
  set_has_site();
  site_ = value;
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.site)
}

// optional .waf_format.Details details = 10;
inline bool Waf_Format::has_details() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Waf_Format::set_has_details() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Waf_Format::clear_has_details() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Waf_Format::clear_details() {
  if (details_ != NULL) details_->Clear();
  clear_has_details();
}
inline const ::waf_format::Details& Waf_Format::details() const {
  const ::waf_format::Details* p = details_;
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.details)
  return p != NULL ? *p : *reinterpret_cast<const ::waf_format::Details*>(
      &::waf_format::_Details_default_instance_);
}
inline ::waf_format::Details* Waf_Format::release_details() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.details)
  clear_has_details();
  ::waf_format::Details* temp = details_;
  details_ = NULL;
  return temp;
}
inline ::waf_format::Details* Waf_Format::mutable_details() {
  set_has_details();
  if (details_ == NULL) {
    details_ = new ::waf_format::Details;
  }
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.details)
  return details_;
}
inline void Waf_Format::set_allocated_details(::waf_format::Details* details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete details_;
  }
  if (details) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    set_has_details();
  } else {
    clear_has_details();
  }
  details_ = details;
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.details)
}

// optional string hostname = 11;
inline bool Waf_Format::has_hostname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Waf_Format::set_has_hostname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Waf_Format::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Waf_Format::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& Waf_Format::hostname() const {
  // @@protoc_insertion_point(field_get:waf_format.Waf_Format.hostname)
  return hostname_.GetNoArena();
}
inline void Waf_Format::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:waf_format.Waf_Format.hostname)
}
#if LANG_CXX11
inline void Waf_Format::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:waf_format.Waf_Format.hostname)
}
#endif
inline void Waf_Format::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:waf_format.Waf_Format.hostname)
}
inline void Waf_Format::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:waf_format.Waf_Format.hostname)
}
inline ::std::string* Waf_Format::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:waf_format.Waf_Format.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Waf_Format::release_hostname() {
  // @@protoc_insertion_point(field_release:waf_format.Waf_Format.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Waf_Format::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:waf_format.Waf_Format.hostname)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace waf_format

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::waf_format::Waf_Format_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waf_format::Waf_Format_ActionType>() {
  return ::waf_format::Waf_Format_ActionType_descriptor();
}
template <> struct is_proto_enum< ::waf_format::Waf_Format_SiteType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::waf_format::Waf_Format_SiteType>() {
  return ::waf_format::Waf_Format_SiteType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_waf_5fformat_2eproto__INCLUDED
